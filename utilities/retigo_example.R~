# retigo_example.R
#
# Purpose: Show how to use the export_retigo function in retigo_utilities.R
#          to generate a RETIGO file given an R dataframe with proper
#          column names.
#
# Assumptions:
#
#   1) Data has already been brought into R by some means. In this example
#      we will simply create the sample data from scratch, then call the 
#      export_retigo function to generate a RETIGO file.
#
#   2) Enough data is available to produce a RETIGO file. This includes a
#      timestamp, latitude, longitude, ID, and at least one scalar data
#      value for each data point.
#
#
# Author: Matt Freeman freeman.matt@epa.gov
#
###############################################################################


###
### In this example, suppose we have 10 data samples, each with one or more
### data values, a date and time of collection, a latitude, a longitude, and 
### an ID string. Think of a data sample as one row of a spreadsheet. Initially, 
### the numerical values for each sample are arranged in separate R arrays and/or 
### scalars, as might be the case if the information is obtained from different 
### instruments or sources. 
###
### To create a RETIGO file, we will have to create an ISO-8601 timestamp from 
### the pertinent date/time information, and then construct a dataframe which 
### contains all of the information for each data sample. The dataframe will be 
### passed to the export_retigo() utility function, which will create a RETIGO 
### file on disk.
###



### First, we create 10 sample data points, with the components in separate 
### arrays. This mimics a situation where the data comes from different 
### instruments or sources.

# Number of data points.
N <- 10 

# Year, month, day, and GMT offset for timezone.
# For this example, assume these values were not automatically logged for each 
# data sample. Instead, they are provided as follows:

YYYY       <- 2012  ## Four digit year
MM         <- 8     ## Month (8 = August)
DD         <- 17    ## Day of month
gmt_offset <- -4    ## An offset of -4 corresponds to EDT timezone

# Hour, minute, and second, logged for each data point.
hh   <- c(07, 07, 07, 07, 07, 07, 07, 07, 07, 07)
mm   <- c(27, 27, 28, 28, 29, 29, 30, 30, 31, 31)
ss   <- c(00, 30, 00, 30, 00, 30, 00, 30, 00, 30)

# Latitude and longitude for each data point, as logged from our instrument.
lat <- c(35.9084,
         35.9045,
         35.9033,
         35.903,
         35.9031,
         35.905,
         35.9102,
         35.9159,
         35.9185,
         35.9186)

lon <- c(-78.9777,
         -78.9703,
         -78.9619,
         -78.9601,
         -78.96,
         -78.9601,
         -78.9606,
         -78.9613,
         -78.9615,
         -78.9615)

# ID tags for each data point.
id <- c("mytag1",
        "mytag2",
        "mytag1",
        "mytag1",
        "mytag1",
        "mytag2",
        "mytag2",
        "mytag1",
        "mytag2",
        "mytag1")

# Data that was measured.
dataName1 <- "BC(ug/m^3)" #important to include units with the data!
data1     <- c(8.077,
               8.702,
               5.5715,
               8.099,
               7.674,
               4.325,
               5.263,
               2.1557,
               -9999,
               2.8595)

dataName2 <- "NO2(ppb)" #important to include units with the data!
data2     <- c(10.442,
               20.886,
               21.431,
               10.383,
               10.438,
               8.585,
               7.35,
               4.527,
               10.156,
               10.383)




###
### Now that we have data to work with, the next step is to create an array 
### of ISO-8601 timestamps from the date and time information.
###
timestamp <- vector("character", N)
if (gmt_offset > 0) {
  offset_sign = "+"
} else {
  offset_sign = "-"
}
for (i in 1:N) {
  timestamp[i] <- sprintf("%04d-%02d-%02dT%02d:%02d:%02d%s%02d:00", 
                          YYYY, 
                          MM, 
                          DD, 
                          hh[i], 
                          mm[i], 
                          ss[i], 
                          offset_sign, 
                          abs(gmt_offset))
}


###
### Assemble all of the pertinent information into a dataframe. The columns 
### do not need to be in any particular order.
###
data <- data.frame(timestamp,
                   data1,
                   data2,
                   lat,
                   lon,
                   id) 

###
### Assign the proper column names to the dataframe.
###
### Important: make sure the units are included in the description
### of the data column(s). This is the only way RETIGO (or people using
### your file) will know what units were used. If you don't know the units, 
### now is the time to find out! This way you can avoid propagating 
### incomplete information downstream.
###
colnames(data) <- c("Timestamp(UTC)",
                    dataName1,
                    dataName2,
                    "NORTH_LATITUDE(deg)",
                    "EAST_LONGITUDE(deg)",
                    "ID(-)")


###
### Send the dataframe to export_retigo() for export into RETIGO format
###

# make sure that RETIGO utilities file has been loaded
#if (!exists('UTIL_RETIGO')) {
  source("retigo_utilities.R")
#}

# set filename 
output_filename <- "./retigo_output.csv"

# export data to RETIGO file
cat("Writing ", output_filename, "...\n", sep="") 
export_retigo(output_filename, data)





###
### Optional: here are examples of how to transform position coordinates 
### (in case we don't have decimal degrees) 
###

# Convert degrees, minutes, seconds to decimal degrees
degrees <- -78
minutes <- -52
seconds <- -12.01
decimal_degrees <- dms_to_decimal(degrees, minutes, seconds)
# print the results of the conversion
cat(sprintf("DMS: (%d, %d, %f) = %f degrees\n", degrees, minutes, seconds, decimal_degrees))


# Convert Universal Transverse Mercator (UTM) coordinates
# to longitude/longitude (requires "rgdal" library)
easting <- 691914
northing <- 3973580
zone <- 17
datum <- "WGS84"
lonlat <- utm_to_latlon(easting, northing, zone, datum)
# print the results of the conversion
cat(sprintf("UTM (%f, %f, %d) = (%f, %f)\n", easting, northing, zone, lonlat[2], lonlat[1]))
